#!/bin/bash

#hashref: content based files references
#Copyright (C) 2012 Carlos Antelo

#This program is free software: you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation, either version 3 of the License, or
#(at your option) any later version.

#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.

#You should have received a copy of the GNU General Public License
#along with this program.  If not, see <http://www.gnu.org/licenses/>.

version="0.1beta1" 

_print_help() {
  cat <<"  EOF" | cut -c5-
    hashref provides a simple mechanism for tracking the 
    content of files across renaming.

    On execution the .hashref directory is created on the 
    current path, tracking the contents of every file below it.

    USAGE:
    hashref [ [ -f PATH ] [ -p ] [ -d ] ] | [ [ -v ] | [ -h ] ]

    OPTIONS:
      -f: src folder
      -p: purge before running
      -d: debug
      -v: version
      -h: this message

    Files are hardlinked inside the .hashref/objects folder
    with a name matching it's sha1 hash.

    The first 2 characters of the hash, correspond to a 
    directory name, the rest is used for the actual filename. 

    A special file called VERSION is kept inside .hashref
    for future incompatibilities.

    Instructing rsync to preserve hardlinks while including
    .hashref will avoid the transfer of files on the basis
    of renaming.

  EOF
}

# parameter processing

purge=no
nextcwd=./

while getopts f:pdvh PARAM; do
  case $PARAM in
    f) nextcwd=$OPTARG;;
    p) purge=yes;;
    d) set -x;;
    v) echo "$version"; exit 0;;
    h) _print_help; exit 0;;
   \?) _print_help; exit 1;;
  esac
done

files() {
  find . -type f -not -wholename '*/.hashref/*' -print0
}

hlink() {
  local IFS=''
  while read -r -d $'\0' filename; do
    # get a hash for the contents of the file 
    sha1_file=$(sha1sum "$filename" | cut -d' ' -f1)

    # segregate files, using the first two characters as
    # a folder name
    mkdir -p .hashref/objects/$(echo "$sha1_file" | cut -c 1-2)
    object_name=$(echo "$sha1_file" | sed 's@..@&/@')

    # hardlink the file using it's hash as filename
    cp -l -f "./$filename" .hashref/objects/"$object_name"
  done
}

cd "$nextcwd"

# clean the .hashref directory
if [ "$purge" = yes ]; then
  rm -rf .hashref
fi

# find and hardlink files
files | hlink

# usefully for future incompatibilities
echo "$version"> .hashref/VERSION

